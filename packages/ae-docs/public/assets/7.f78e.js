(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{"./packages/ae-docs/pages/Task.mdx":function(e,a,n){"use strict";n.r(a),n.d(a,"default",function(){return g});var s=n("./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js"),t=n("./node_modules/@babel/runtime/helpers/esm/classCallCheck.js"),m=n("./node_modules/@babel/runtime/helpers/esm/createClass.js"),o=n("./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js"),p=n("./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js"),c=n("./node_modules/@babel/runtime/helpers/esm/inherits.js"),l=n("./node_modules/react/index.js"),r=n.n(l),N=n("./node_modules/@mdx-js/tag/dist/index.js"),g=function(e){function a(e){var n;return Object(t.a)(this,a),(n=Object(o.a)(this,Object(p.a)(a).call(this,e))).layout=null,n}return Object(c.a)(a,e),Object(m.a)(a,[{key:"render",value:function(){var e=this.props,a=e.components;Object(s.a)(e,["components"]);return r.a.createElement(N.MDXTag,{name:"wrapper",components:a},r.a.createElement(N.MDXTag,{name:"h1",components:a,props:{id:"task-monad"}},"Task monad"),r.a.createElement(N.MDXTag,{name:"p",components:a},"A lightweight asynchronous, lazy, cancellable task monad. Running an effectful program returns an instance of a Task"),r.a.createElement(N.MDXTag,{name:"hr",components:a}),r.a.createElement(N.MDXTag,{name:"h2",components:a,props:{id:"import-it-in-your-project"}},"Import it in your project"),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"import")," Task ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"from")," ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},"'@algebraic-effects/task'"),";\n",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"import")," { race, parallel, bimap, fork } ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"from")," ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},"'@algebraic-effects/task/fns'"),"; ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-comment"}},"// Helper functions. Also includes point-free alternatives for Task#method"))),r.a.createElement(N.MDXTag,{name:"h2",components:a,props:{id:"api"}},"API"),r.a.createElement(N.MDXTag,{name:"h3",components:a,props:{id:"task-constructor"}},"Task constructor"),r.a.createElement(N.MDXTag,{name:"p",components:a},"You can pass it the initial state for your program and run it."),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," :: (e -> (), a -> (), * -> ()) -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"const")," waitASec = Task(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-function"}},"(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-params"}},"reject, resolve, cancel"),") =>")," setTimeout(resolve, ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"1000"),"));")),r.a.createElement(N.MDXTag,{name:"h3",components:a,props:{id:"static-methods"}},"Static methods"),r.a.createElement(N.MDXTag,{name:"ul",components:a},r.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"Task.of"),", ",r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"Task.Resolved"),r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"Task.of")," is an alias for ",r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"Task.Resolved")," which creates a resolved task with the given value.")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task"),".",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"of")," :: a -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task"),".",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Resolved")," a\n",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task"),".",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Resolved")," :: a -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task"),".",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Resolved")," a")),r.a.createElement(N.MDXTag,{name:"ul",components:a},r.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"Task.Rejected"),r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"Task.Rejected")," creates a rejected/failed task with the given value.")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task"),".",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Rejected")," :: e -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task"),".",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Rejected")," e")),r.a.createElement(N.MDXTag,{name:"ul",components:a},r.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"Task.Empty"),r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"Task.Empty")," creates a task which will never resolve or get rejected. You can call ",r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"rejectWith")," or ",r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"resolveWith")," methods on the task instance to make the task reject or resolve.")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task"),".",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Empty")," :: () -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task"),".",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Empty"))),r.a.createElement(N.MDXTag,{name:"ul",components:a},r.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"Task.fromPromise"),r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"Task.empty")," creates a task which will never resolve or get rejected. You can call ",r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"rejectWith")," or ",r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"resolveWith")," methods on the task instance to make the task reject or resolve.")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task"),".fromPromise :: (() -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Promise")," e a) -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},"Task.fromPromise(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-function"}},r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-params"}},"()")," =>")," fetch(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},"'/api'"),").then(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-function"}},r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-params"}},"r")," =>")," r.json()));")),r.a.createElement(N.MDXTag,{name:"p",components:a},"You can also pass it an async function as it returns a promise."),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},"Task.fromPromise(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"async")," ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-function"}},r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-keyword"}},"function"),"(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-params"}}),") "),"{\n  ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"const")," response = ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"await")," fetch(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},"'/api'"),");\n  ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"return")," response.json();\n})")),r.a.createElement(N.MDXTag,{name:"h3",components:a,props:{id:"instance-methods"}},"Instance methods"),r.a.createElement(N.MDXTag,{name:"ul",components:a},r.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"fork"),r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"fork")," is the function that runs your task and allows to to handle to result of execution. ",r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"Task")," is lazy so you can compose your functions and it will only execute the chain when this method is called. When you call this method, you will recieve a cancel function in return. Calling this function will cancel your task.")),r.a.createElement(N.MDXTag,{name:"p",components:a},"NOTE: All handlers are optional. So, you can pass 0 arguements to fork if you dont care about the result."),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},"(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a).fork :: (e -> (), a -> (), * -> ()) -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"CancelFunction"),"\n(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a).fork :: ({ ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Rejected")," :: e -> (), ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Resolved")," :: a -> (), ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Cancelled"),": * -> () }) -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"CancelFunction"))),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"const")," cancelTimeout = Task(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-function"}},"(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-params"}},"_, resolve"),") =>")," setTimeout(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-function"}},r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-params"}},"()")," =>")," resolve(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"10"),"), ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"1000"),"))\n  .fork(handleError, ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-built_in"}},"console"),".log, handleCancel); ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-comment"}},"// Will log 10 to console"),"\n\ncancelTimeout();\n",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-comment"}},"// Call cancelTimeout() will prevent the console.log and will instead call only handleCancel"))),r.a.createElement(N.MDXTag,{name:"p",components:a},"Of you can call cancel from inside the task"),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"const")," task = Task(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-function"}},"(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-params"}},"_, resolve, cancel"),") =>")," {\n  cancel(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"5"),");\n});\n\ntask.fork({\n  ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-attr"}},"Cancelled"),": ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-function"}},r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-params"}},"data")," =>")," {\n    ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-built_in"}},"console"),".log(data); ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-comment"}},"// > 5"),"\n  },\n});")),r.a.createElement(N.MDXTag,{name:"ul",components:a},r.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"map"),r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"map")," method allows you to map over a value in the ",r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"Task")," i.e. transform the resolved value inside the task")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},"(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a).map :: (a -> b) -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e b")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},"Task.of(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"10"),")\n  .map(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-function"}},r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-params"}},"x")," =>")," x + ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"1"),")\n  .fork(handleError, ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-built_in"}},"console"),".log); ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-comment"}},"// Will log 11 to console"))),r.a.createElement(N.MDXTag,{name:"ul",components:a},r.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"mapRejected"),r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"mapRejected")," method allows you to map over a the rejected value in the ",r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"Task"),". So it will only map over e and ignore resolved values.")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},"(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a).mapRejected :: (a -> b) -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e b")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},"Task.Rejected(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},"'Something went wrong'"),")\n  .mapRejected(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-function"}},r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-params"}},"e")," =>")," ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},"`ERROR: ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-subst"}},"${e}"),"`"),")\n  .fork(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-built_in"}},"console"),".error, handleSuccess); ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-comment"}},'// Will log error "ERROR: Something went wrong"'))),r.a.createElement(N.MDXTag,{name:"ul",components:a},r.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"chain"),r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"chain")," method allows you to map over a value in the ",r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"Task")," with a function that returns another task and merges the nested tasks. It behaves similar to how flatMap behaves with arrays.")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},"(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a).chain :: (a -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e' b) -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," (e|e') b")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},"Task.of(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"10"),")\n  .chain(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-function"}},r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-params"}},"x")," =>")," Task(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-function"}},"(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-params"}},"_, resolve"),") =>")," setTimeout(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-function"}},r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-params"}},"()")," =>")," resolve(x + ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"1"),"), ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"1000"),")))\n  .fork(handleError, ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-built_in"}},"console"),".log); ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-comment"}},"// Will log 11 to console after 1 second"))),r.a.createElement(N.MDXTag,{name:"ul",components:a},r.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"bimap"),"\nWhere with ",r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"map")," you can only map over a resolved value in a Task, ",r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"bimap")," allows you to map over the resolved and the rejected value.")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},"(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a).bimap :: (e -> e', a -> a') -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e' a'")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},"someTask\n  .bimap(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-function"}},r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-params"}},"e")," =>")," ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},"`",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-subst"}},"${e}")," - Something went wrong`"),", x => x + ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"1"),")\n  .fork(handleError, handleSuccess);")),r.a.createElement(N.MDXTag,{name:"ul",components:a},r.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"fold"),r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"fold")," is similar to ",r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"bimap")," with the only difference being that the resolved or rejected value is wrapped.")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},"(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a).fold :: (e -> b, a -> b) -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task"),".",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Resolved")," b")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},"someTask\n  .fold(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-function"}},r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-params"}},"()")," =>")," ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"10"),", x => x + ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"10"),")\n  .fork(() = {}, handleResult); ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-comment"}},"// Handle result will get a 10 if the task is rejected, else, it will get (resolved value + 10)"),"\n\nsomeOtherTask\n  .fold(Either.Left, Either.Right)\n  .fork(() = {}, handleResult); ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-comment"}},"// Will convert the result into an Either"))),r.a.createElement(N.MDXTag,{name:"ul",components:a},r.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"resolveWith"),", ",r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"rejectWith"),", ",r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"empty"),"\nThese methods allow you to ignore everything that happened before it and resolve or reject with a value or just empty out the task.")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},"(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a).resolveWith :: a' -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task"),".",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Resolved")," a'\n(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a).rejectWith :: e' -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task"),".",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Rejected")," e'\n(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a).empty :: () -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task"),".",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Empty"))),r.a.createElement(N.MDXTag,{name:"ul",components:a},r.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"toPromise"),"\nConvert the given task to a promise.\nNOTE: This will immediately execute your task.")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},"(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a).toPromise :: () -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Promise")," e a")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},"someTask\n  .toPromise()\n  .then(handleSuccess)\n  .catch(handleError);")),r.a.createElement(N.MDXTag,{name:"h3",components:a,props:{id:"helper-functions"}},"Helper functions"),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"import")," { rejectAfter, race, parallel } ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"from")," ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},"'@algebraic-effects/task/fns'"),";")),r.a.createElement(N.MDXTag,{name:"ul",components:a},r.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"resolveAfter"),"\nWill resolve with a given value after a delay")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-title"}},"resolveAfter")," :: (",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Number"),", a) -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task"),".",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Resolved")," a")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},"resolveAfter(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"1000"),", ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"5"),")\n  .fork(handleError, handleSuccess);")),r.a.createElement(N.MDXTag,{name:"ul",components:a},r.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"rejectAfter"),"\nWill reject with a given value after a delay")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-title"}},"rejectAfter")," :: (",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Number"),", e) -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task"),".",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Rejected")," e")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},"rejectAfter(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"1000"),", ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"5"),")\n  .fork(handleError, handleSuccess);")),r.a.createElement(N.MDXTag,{name:"ul",components:a},r.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"race"),"\nResolve or Reject with the first task tha reaches completion.")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-title"}},"race")," :: [",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a] -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},"race([ fetchResource, rejectAfter(",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"2000"),"), ])\n  .fork(handleError, handleSuccess);")),r.a.createElement(N.MDXTag,{name:"ul",components:a},r.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"series"),"\nRun a given set of tasks one after the other and resolve with a list of results. Fail if one of the tasks fail.")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-title"}},"series")," :: [",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a] -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e [a]")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},"series([ fetchResourceA, fetchResourceB,, fetchResourceC ])\n  .fork(handleError, ([ a, b, c ]) => handleSuccess(a, b, c));")),r.a.createElement(N.MDXTag,{name:"ul",components:a},r.a.createElement(N.MDXTag,{name:"li",components:a,parentName:"ul"},r.a.createElement(N.MDXTag,{name:"inlineCode",components:a,parentName:"li"},"parallel"),"\nRun a given set of tasks parallely. Fail if one of the tasks fail.")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-title"}},"parallel")," :: [",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a] -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e [a]")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-js"}},"parallel([ fetchResourceA, fetchResourceB, fetchResourceC ])\n  .fork(handleError, ([ a, b, c ]) => handleSuccess(a, b, c));")),r.a.createElement(N.MDXTag,{name:"h3",components:a,props:{id:"point-free-functions"}},"Point free functions"),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-title"}},"map")," :: (a -> b) -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e b")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-title"}},"mapRejected")," :: (e -> e') -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e' a")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-title"}},"bimap")," :: (e -> e', a -> a') -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e' a'")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-title"}},"fold")," :: (e -> b, a -> b) -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task"),".",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Resolved")," b")),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-title"}},"fork")," :: (e -> (), a -> ()) -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"CancelFunction"))),r.a.createElement(N.MDXTag,{name:"pre",components:a},r.a.createElement(N.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-haskell"}},r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-title"}},"toPromise")," :: ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Task")," e a -> ",r.a.createElement(N.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-type"}},"Promise")," e b")))}}]),a}(r.a.Component)}}]);